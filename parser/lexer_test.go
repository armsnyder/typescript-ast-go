package parser

import (
	"fmt"
	"os"
	"testing"

	"github.com/armsnyder/typescript-ast-go/token"
)

func TestLexer(t *testing.T) {
	tests := []struct {
		testdata string
		want     []token.Token
	}{
		{
			testdata: "array",
			want: []token.Token{
				{Kind: token.Comment, Text: "LSP arrays.\n\n@since 3.17.0"},
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "type"},
				{Kind: token.Ident, Text: "LSPArray"},
				{Kind: token.Assign},
				{Kind: token.Ident, Text: "LSPAny"},
				{Kind: token.LBrack},
				{Kind: token.RBrack},
				{Kind: token.Semicolon},
			},
		},
		{
			testdata: "basic_type",
			want: []token.Token{
				{Kind: token.Comment, Text: "Defines an integer number in the range of -2^31 to 2^31 - 1."},
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "type"},
				{Kind: token.Ident, Text: "integer"},
				{Kind: token.Assign},
				{Kind: token.Ident, Text: "number"},
				{Kind: token.Semicolon},
			},
		},
		{
			testdata: "enum",
			want: []token.Token{
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "enum"},
				{Kind: token.Ident, Text: "SemanticTokenTypes"},
				{Kind: token.LBrace},
				{Kind: token.Ident, Text: "namespace"},
				{Kind: token.Assign},
				{Kind: token.String, Text: "namespace"},
				{Kind: token.Comma},
				{Kind: token.Comment, Text: "Represents a generic type. Acts as a fallback for types which\ncan't be mapped to a specific type like class or enum."},
				{Kind: token.Ident, Text: "type"},
				{Kind: token.Assign},
				{Kind: token.String, Text: "type"},
				{Kind: token.Comma},
				{Kind: token.Ident, Text: "class"},
				{Kind: token.Assign},
				{Kind: token.String, Text: "class"},
				{Kind: token.Comma},
				{Kind: token.Ident, Text: "enum"},
				{Kind: token.Assign},
				{Kind: token.String, Text: "enum"},
				{Kind: token.Comma},
				{Kind: token.Ident, Text: "interface"},
				{Kind: token.Assign},
				{Kind: token.String, Text: "interface"},
				{Kind: token.Comma},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Assign},
				{Kind: token.String, Text: "string"},
				{Kind: token.Comma},
				{Kind: token.RBrace},
			},
		},
		{
			testdata: "generic",
			want: []token.Token{
				{Kind: token.Ident, Text: "interface"},
				{Kind: token.Ident, Text: "ProgressParams"},
				{Kind: token.LAngle},
				{Kind: token.Ident, Text: "T"},
				{Kind: token.RAngle},
				{Kind: token.LBrace},
				{Kind: token.Comment, Text: "The progress token provided by the client or server."},
				{Kind: token.Ident, Text: "token"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "ProgressToken"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "The progress data."},
				{Kind: token.Ident, Text: "value"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "T"},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
			},
		},
		{
			testdata: "inline_type",
			want: []token.Token{
				{Kind: token.Ident, Text: "interface"},
				{Kind: token.Ident, Text: "HoverParams"},
				{Kind: token.LBrace},
				{Kind: token.Ident, Text: "textDocument"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Semicolon},
				{Kind: token.LineComment, Text: "The text document's URI in string form"},
				{Kind: token.Ident, Text: "position"},
				{Kind: token.Colon},
				{Kind: token.LBrace},
				{Kind: token.Ident, Text: "line"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "uinteger"},
				{Kind: token.Semicolon},
				{Kind: token.Ident, Text: "character"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "uinteger"},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
			},
		},
		{
			testdata: "interface",
			want: []token.Token{
				{Kind: token.Ident, Text: "interface"},
				{Kind: token.Ident, Text: "ResponseMessage"},
				{Kind: token.Ident, Text: "extends"},
				{Kind: token.Ident, Text: "Message"},
				{Kind: token.LBrace},
				{Kind: token.Comment, Text: "The request id."},
				{Kind: token.Ident, Text: "id"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "integer"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "null"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "The result of a request. This member is REQUIRED on success.\nThis member MUST NOT exist if there was an error invoking the method."},
				{Kind: token.Ident, Text: "result"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "number"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "boolean"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "array"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "object"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "null"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "The error object in case a request fails."},
				{Kind: token.Ident, Text: "error"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "ResponseError"},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
			},
		},
		{
			testdata: "interface_complex_syntax",
			want: []token.Token{
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "interface"},
				{Kind: token.Ident, Text: "WorkspaceEdit"},
				{Kind: token.LBrace},
				{Kind: token.Comment, Text: "Holds changes to existing resources."},
				{Kind: token.Ident, Text: "changes"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.LBrace},
				{Kind: token.LBrack},
				{Kind: token.Ident, Text: "uri"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "DocumentUri"},
				{Kind: token.RBrack},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "TextEdit"},
				{Kind: token.LBrack},
				{Kind: token.RBrack},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "Depending on the client capability\n`workspace.workspaceEdit.resourceOperations` document changes are either\nan array of `TextDocumentEdit`s to express changes to n different text\ndocuments where each text document edit addresses a specific version of\na text document. Or it can contain above `TextDocumentEdit`s mixed with\ncreate, rename and delete file / folder operations.\n\nWhether a client supports versioned document edits is expressed via\n`workspace.workspaceEdit.documentChanges` client capability.\n\nIf a client neither supports `documentChanges` nor\n`workspace.workspaceEdit.resourceOperations` then only plain `TextEdit`s\nusing the `changes` property are supported."},
				{Kind: token.Ident, Text: "documentChanges"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.LParen},
				{Kind: token.Ident, Text: "TextDocumentEdit"},
				{Kind: token.LBrack},
				{Kind: token.RBrack},
				{Kind: token.Or},
				{Kind: token.LParen},
				{Kind: token.Ident, Text: "TextDocumentEdit"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "CreateFile"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "RenameFile"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "DeleteFile"},
				{Kind: token.RParen},
				{Kind: token.LBrack},
				{Kind: token.RBrack},
				{Kind: token.RParen},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "A map of change annotations that can be referenced in\n`AnnotatedTextEdit`s or create, rename and delete file / folder\noperations.\n\nWhether clients honor this property depends on the client capability\n`workspace.changeAnnotationSupport`.\n\n@since 3.16.0"},
				{Kind: token.Ident, Text: "changeAnnotations"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.LBrace},
				{Kind: token.LBrack},
				{Kind: token.Ident, Text: "id"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.LineComment, Text: "ChangeAnnotationIdentifier"},
				{Kind: token.RBrack},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "ChangeAnnotation"},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
			},
		},
		{
			testdata: "interface_with_union_array",
			want: []token.Token{
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "interface"},
				{Kind: token.Ident, Text: "TextDocumentEdit"},
				{Kind: token.LBrace},
				{Kind: token.Comment, Text: "The edits to be applied.\n\n@since 3.16.0 - support for AnnotatedTextEdit. This is guarded by the\nclient capability `workspace.workspaceEdit.changeAnnotationSupport`"},
				{Kind: token.Ident, Text: "edits"},
				{Kind: token.Colon},
				{Kind: token.LParen},
				{Kind: token.Ident, Text: "TextEdit"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "AnnotatedTextEdit"},
				{Kind: token.RParen},
				{Kind: token.LBrack},
				{Kind: token.RBrack},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
			},
		},
		{
			testdata: "interface_with_union_struct_field",
			want: []token.Token{
				{Kind: token.Comment, Text: "Options specific to a notebook plus its cells\nto be synced to the server.\n\nIf a selector provides a notebook document\nfilter but no cell selector all cells of a\nmatching notebook document will be synced.\n\nIf a selector provides no notebook document\nfilter but only a cell selector all notebook\ndocuments that contain at least one matching\ncell will be synced.\n\n@since 3.17.0"},
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "interface"},
				{Kind: token.Ident, Text: "NotebookDocumentSyncOptions"},
				{Kind: token.LBrace},
				{Kind: token.Comment, Text: "The notebooks to be synced"},
				{Kind: token.Ident, Text: "notebookSelector"},
				{Kind: token.Colon},
				{Kind: token.LParen},
				{Kind: token.LBrace},
				{Kind: token.Comment, Text: "The notebook to be synced. If a string\nvalue is provided it matches against the\nnotebook type. '*' matches every notebook."},
				{Kind: token.Ident, Text: "notebook"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "NotebookDocumentFilter"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "The cells of the matching notebook to be synced."},
				{Kind: token.Ident, Text: "cells"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.LBrace},
				{Kind: token.Ident, Text: "language"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.RBrace},
				{Kind: token.LBrack},
				{Kind: token.RBrack},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
				{Kind: token.Or},
				{Kind: token.LBrace},
				{Kind: token.Comment, Text: "The notebook to be synced. If a string\nvalue is provided it matches against the\nnotebook type. '*' matches every notebook."},
				{Kind: token.Ident, Text: "notebook"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "NotebookDocumentFilter"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "The cells of the matching notebook to be synced."},
				{Kind: token.Ident, Text: "cells"},
				{Kind: token.Colon},
				{Kind: token.LBrace},
				{Kind: token.Ident, Text: "language"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.RBrace},
				{Kind: token.LBrack},
				{Kind: token.RBrack},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
				{Kind: token.RParen},
				{Kind: token.LBrack},
				{Kind: token.RBrack},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "Whether save notification should be forwarded to\nthe server. Will only be honored if mode === `notebook`."},
				{Kind: token.Ident, Text: "save"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "boolean"},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
			},
		},
		{
			testdata: "multiple_extends",
			want: []token.Token{
				{Kind: token.Comment, Text: "Registration options specific to a notebook.\n\n@since 3.17.0"},
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "interface"},
				{Kind: token.Ident, Text: "NotebookDocumentSyncRegistrationOptions"},
				{Kind: token.Ident, Text: "extends"},
				{Kind: token.Ident, Text: "NotebookDocumentSyncOptions"},
				{Kind: token.Comma},
				{Kind: token.Ident, Text: "StaticRegistrationOptions"},
				{Kind: token.LBrace},
				{Kind: token.RBrace},
			},
		},
		{
			testdata: "namespace",
			want: []token.Token{
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "namespace"},
				{Kind: token.Ident, Text: "ErrorCodes"},
				{Kind: token.LBrace},
				{Kind: token.Comment, Text: "Defined by JSON-RPC"},
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "const"},
				{Kind: token.Ident, Text: "ParseError"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "integer"},
				{Kind: token.Assign},
				{Kind: token.Minus},
				{Kind: token.Number, Text: "32700"},
				{Kind: token.Semicolon},
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "const"},
				{Kind: token.Ident, Text: "InvalidRequest"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "integer"},
				{Kind: token.Assign},
				{Kind: token.Minus},
				{Kind: token.Number, Text: "32600"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "This is the start range of JSON-RPC reserved error codes.\nIt doesn't denote a real error code. No LSP error codes should\nbe defined between the start and end range. For backwards\ncompatibility the `ServerNotInitialized` and the `UnknownErrorCode`\nare left in the range.\n\n@since 3.16.0"},
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "const"},
				{Kind: token.Ident, Text: "jsonrpcReservedErrorRangeStart"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "integer"},
				{Kind: token.Assign},
				{Kind: token.Minus},
				{Kind: token.Number, Text: "32099"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "@deprecated use jsonrpcReservedErrorRangeStart"},
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "const"},
				{Kind: token.Ident, Text: "serverErrorStart"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "integer"},
				{Kind: token.Assign},
				{Kind: token.Ident, Text: "jsonrpcReservedErrorRangeStart"},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
			},
		},
		{
			testdata: "object",
			want: []token.Token{
				{Kind: token.Comment, Text: "LSP object definition.\n\n@since 3.17.0"},
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "type"},
				{Kind: token.Ident, Text: "LSPObject"},
				{Kind: token.Assign},
				{Kind: token.LBrace},
				{Kind: token.LBrack},
				{Kind: token.Ident, Text: "key"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.RBrack},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "LSPAny"},
				{Kind: token.RBrace},
				{Kind: token.Semicolon},
			},
		},
		{
			testdata: "readonly",
			want: []token.Token{
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "interface"},
				{Kind: token.Ident, Text: "SemanticTokensDelta"},
				{Kind: token.LBrace},
				{Kind: token.Ident, Text: "readonly"},
				{Kind: token.Ident, Text: "resultId"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "The semantic token edits to transform a previous result into a new\nresult."},
				{Kind: token.Ident, Text: "edits"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "SemanticTokensEdit"},
				{Kind: token.LBrack},
				{Kind: token.RBrack},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
			},
		},
		{
			testdata: "union_struct",
			want: []token.Token{
				{Kind: token.Comment, Text: "A notebook document filter denotes a notebook document by\ndifferent properties.\n\n@since 3.17.0"},
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "type"},
				{Kind: token.Ident, Text: "NotebookDocumentFilter"},
				{Kind: token.Assign},
				{Kind: token.LBrace},
				{Kind: token.Comment, Text: "The type of the enclosing notebook."},
				{Kind: token.Ident, Text: "notebookType"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "A Uri [scheme](#Uri.scheme), like `file` or `untitled`."},
				{Kind: token.Ident, Text: "scheme"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "A glob pattern."},
				{Kind: token.Ident, Text: "pattern"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
				{Kind: token.Or},
				{Kind: token.LBrace},
				{Kind: token.Comment, Text: "The type of the enclosing notebook."},
				{Kind: token.Ident, Text: "notebookType"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "A Uri [scheme](#Uri.scheme), like `file` or `untitled`."},
				{Kind: token.Ident, Text: "scheme"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "A glob pattern."},
				{Kind: token.Ident, Text: "pattern"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
				{Kind: token.Or},
				{Kind: token.LBrace},
				{Kind: token.Comment, Text: "The type of the enclosing notebook."},
				{Kind: token.Ident, Text: "notebookType"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "A Uri [scheme](#Uri.scheme), like `file` or `untitled`."},
				{Kind: token.Ident, Text: "scheme"},
				{Kind: token.Question},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Semicolon},
				{Kind: token.Comment, Text: "A glob pattern."},
				{Kind: token.Ident, Text: "pattern"},
				{Kind: token.Colon},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Semicolon},
				{Kind: token.RBrace},
				{Kind: token.Semicolon},
			},
		},
		{
			testdata: "union_type",
			// [Comment("The LSP any type\n\n@since 3.17.0") Ident, Text: "export" Type Ident("LSPAny") Assign Ident("LSPObject") Or Ident("LSPArray") Or Ident("string") Or Ident("integer") Or Ident("uinteger") Or Ident("decimal") Or Ident("boolean") Or Ident("null") Semicolon]
			want: []token.Token{
				{Kind: token.Comment, Text: "The LSP any type\n\n@since 3.17.0"},
				{Kind: token.Ident, Text: "export"},
				{Kind: token.Ident, Text: "type"},
				{Kind: token.Ident, Text: "LSPAny"},
				{Kind: token.Assign},
				{Kind: token.Ident, Text: "LSPObject"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "LSPArray"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "string"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "integer"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "uinteger"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "decimal"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "boolean"},
				{Kind: token.Or},
				{Kind: token.Ident, Text: "null"},
				{Kind: token.Semicolon},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.testdata, func(t *testing.T) {
			source, err := os.ReadFile(fmt.Sprintf("../internal/testdata/%s.ts.txt", tt.testdata))
			if err != nil {
				t.Fatal(err)
			}

			lex := lexer{Source: source}

			var got []token.Token
			for {
				tok := lex.Pop()
				if tok.Kind == token.EOF {
					break
				}
				got = append(got, tok)
				if tok.Kind == token.Illegal {
					break
				}
			}

			if len(got) != len(tt.want) {
				t.Fatalf("\ngot:\n%v\nwant:\n%v", got, tt.want)
			}

			for i := range got {
				if got[i] != tt.want[i] {
					t.Fatalf("\ngot:\n%v\nwant:\n%v", got, tt.want)
				}
			}
		})
	}
}
